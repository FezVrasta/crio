(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("crio", [], factory);
	else if(typeof exports === 'object')
		exports["crio"] = factory();
	else
		root["crio"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _crioIdentifier = __webpack_require__(2);\n\nvar _crioIdentifier2 = _interopRequireDefault(_crioIdentifier);\n\nvar _utils = __webpack_require__(3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar immutableArrayMethods = {\n  onlyApplyMethods: ['filter', 'slice'],\n  fullCrio: ['join', 'map', 'reduce', 'reduceRight']\n};\n\nvar ASSIGN = Object.assign;\nvar CREATE = Object.create;\nvar DEFINE_PROPERTY = Object.defineProperty;\nvar FREEZE = Object.freeze;\nvar GET_OWN_PROPERTY_DESCRIPTOR = Object.getOwnPropertyDescriptor;\nvar GET_OWN_PROPERTY_NAMES = Object.getOwnPropertyNames;\nvar KEYS = Object.keys;\n\nvar isCrio = function isCrio(object) {\n  return !!object[_crioIdentifier2.default];\n};\n\nvar allAdditionalMethods = {\n  delete: function _delete(key) {\n    if ((0, _utils.isArray)(this)) {\n      return (0, _utils.getRestOfObject)(this, key);\n    }\n\n    return returnFrozenWithMethods(_extends({}, (0, _utils.getRestOfObject)(this, key)), false);\n  },\n  deleteIn: function deleteIn(keys) {\n    if (!(0, _utils.isArray)(keys)) {\n      return this;\n    }\n\n    var lastKeyIndex = keys.length - 1;\n\n    var currentObject = this.thaw(),\n        referenceToCurrentObject = currentObject;\n\n    for (var keyIndex = 0, length = lastKeyIndex + 1; keyIndex < length; keyIndex++) {\n      var key = keys[keyIndex];\n      var currentValue = currentObject[key];\n\n      if (keyIndex === lastKeyIndex) {\n        delete currentObject[key];\n        break;\n      }\n\n      if (!(0, _utils.isArray)(currentValue) && !(0, _utils.isObject)(currentValue)) {\n        return this;\n      }\n\n      currentObject = currentObject[key];\n    }\n\n    return crio(referenceToCurrentObject);\n  },\n  equals: function equals(object) {\n    return (0, _utils.isEqual)(this, object);\n  },\n  get: function get(key) {\n    return this[key];\n  },\n  getIn: function getIn(keys) {\n    if (!(0, _utils.isArray)(keys)) {\n      return this;\n    }\n\n    var lastKeyIndex = keys.length - 1;\n\n    var currentObject = this;\n\n    for (var keyIndex = 0, length = lastKeyIndex + 1; keyIndex < length; keyIndex++) {\n      var key = keys[keyIndex];\n\n      if ((0, _utils.isUndefined)(currentObject[key]) || keyIndex === lastKeyIndex) {\n        return currentObject[key];\n      }\n\n      currentObject = currentObject[key];\n    }\n  },\n  log: function log(title) {\n    var thawed = this.thaw();\n\n    if (title) {\n      console.log(title, thawed);\n    } else {\n      console.log(thawed);\n    }\n\n    return this;\n  },\n  merge: function merge() {\n    var isThisArray = (0, _utils.isArray)(this);\n\n    var shallowClone = isThisArray ? [].concat(_toConsumableArray(this)) : _extends({}, this);\n\n    for (var _len = arguments.length, objects = Array(_len), _key = 0; _key < _len; _key++) {\n      objects[_key] = arguments[_key];\n    }\n\n    objects.forEach(function (object) {\n      for (var key in object) {\n        shallowClone[key] = crio(object[key]);\n      }\n    });\n\n    return returnFrozenWithMethods(shallowClone, isThisArray);\n  },\n  mergeIn: function mergeIn(keys) {\n    if (!(0, _utils.isArray)(keys)) {\n      return this;\n    }\n\n    var lastKeyIndex = keys.length - 1;\n\n    var currentObject = this.thaw(),\n        referenceToCurrentObject = currentObject;\n\n    for (var _len2 = arguments.length, objects = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      objects[_key2 - 1] = arguments[_key2];\n    }\n\n    for (var keyIndex = 0, length = lastKeyIndex + 1; keyIndex < length; keyIndex++) {\n      var key = keys[keyIndex];\n      var currentValue = currentObject[key];\n\n      if (!(0, _utils.isArray)(currentValue) && !(0, _utils.isObject)(currentValue)) {\n        currentObject[key] = {};\n      }\n\n      if (keyIndex === lastKeyIndex) {\n        currentObject[key] = this.merge.apply(currentObject[key], objects);\n        break;\n      }\n\n      currentObject = currentObject[key];\n    }\n\n    return crio(referenceToCurrentObject, (0, _utils.isArray)(this));\n  },\n  mutate: function mutate(mutateMapFunction) {\n    var result = mutateMapFunction.call(this, this.thaw());\n\n    return crio(result);\n  },\n  set: function set(key, value) {\n    if (!key) {\n      return this;\n    }\n\n    var isThisArray = (0, _utils.isArray)(this);\n\n    if (isThisArray) {\n      return this.map(function (item, itemIndex) {\n        if (itemIndex === key) {\n          return crio(value);\n        }\n\n        return item;\n      });\n    }\n\n    return returnFrozenWithMethods(_extends({}, (0, _utils.getRestOfObject)(this, key), _defineProperty({}, key, crio(value))), isThisArray);\n  },\n  setIn: function setIn(keys, value) {\n    if (!(0, _utils.isArray)(keys)) {\n      return this;\n    }\n\n    var lastKeyIndex = keys.length - 1;\n\n    var currentObject = this.thaw(),\n        referenceToCurrentObject = currentObject;\n\n    for (var keyIndex = 0, length = lastKeyIndex + 1; keyIndex < length; keyIndex++) {\n      var key = keys[keyIndex];\n      var currentValue = currentObject[key];\n\n      if (!(0, _utils.isArray)(currentValue) && !(0, _utils.isObject)(currentValue)) {\n        currentObject[key] = {};\n      }\n\n      if (keyIndex === lastKeyIndex) {\n        currentObject[key] = crio(value);\n        break;\n      }\n\n      currentObject = currentObject[key];\n    }\n\n    return crio(referenceToCurrentObject);\n  },\n  thaw: function thaw() {\n    return (0, _utils.getMutableObject)(this);\n  }\n};\nvar arrayAdditionalMethods = {\n  concat: function concat() {\n    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    args.forEach(function (arg, argIndex) {\n      args[argIndex] = crio(arg);\n    });\n\n    return returnFrozenWithMethods(Array.prototype.concat.apply(this, args), true);\n  },\n  copyWithin: function copyWithin(targetIndex, startIndex) {\n    var endIndex = arguments.length <= 2 || arguments[2] === undefined ? this.length : arguments[2];\n\n    targetIndex = (0, _utils.coerceToInteger)(targetIndex);\n    startIndex = (0, _utils.coerceToInteger)(startIndex);\n    endIndex = (0, _utils.coerceToInteger)(endIndex);\n\n    if (startIndex < 0) {\n      startIndex = this.length + startIndex;\n    }\n\n    if (endIndex < 0) {\n      endIndex = this.length + endIndex;\n    }\n\n    var copyValues = this.slice(startIndex, endIndex);\n\n    var copyIndex = 0;\n\n    return this.map(function (item, itemIndex) {\n      if (copyIndex === copyValues.length || itemIndex >= startIndex && itemIndex < endIndex) {\n        return item;\n      }\n\n      copyIndex++;\n\n      return copyValues[copyIndex - 1];\n    });\n  },\n  fill: function fill(value) {\n    var startIndex = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n    var endIndex = arguments.length <= 2 || arguments[2] === undefined ? this.length : arguments[2];\n\n    startIndex = (0, _utils.coerceToInteger)(startIndex);\n    endIndex = (0, _utils.coerceToInteger)(endIndex);\n\n    value = crio(value);\n\n    if (startIndex < 0) {\n      startIndex = this.length + startIndex;\n    }\n\n    if (endIndex < 0) {\n      endIndex = this.length + endIndex;\n    }\n\n    var tempArray = [];\n\n    this.forEach(function (item, itemIndex) {\n      if (itemIndex >= startIndex && itemIndex < endIndex) {\n        tempArray[itemIndex] = value;\n      } else {\n        tempArray[itemIndex] = item;\n      }\n    });\n\n    return returnFrozenWithMethods(tempArray, true);\n  },\n  forEach: function forEach(forEachFunction) {\n    for (var index = 0, length = this.length; index < length; index++) {\n      var result = forEachFunction.call(this, this[index], index, this);\n\n      if (result === false) {\n        return this;\n      }\n    }\n  },\n  pop: function pop() {\n    var tempArray = [].concat(_toConsumableArray(this.slice(0, this.length - 1)));\n\n    return returnFrozenWithMethods(tempArray, true);\n  },\n  push: function push() {\n    var tempArray = [].concat(_toConsumableArray(this)),\n        length = this.length;\n\n    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    args.forEach(function (arg) {\n      (0, _utils.setImmutable)(tempArray, length, crio(arg));\n      length++;\n    });\n\n    return returnFrozenWithMethods(tempArray, true);\n  },\n  reverse: function reverse() {\n    var tempArray = [].concat(_toConsumableArray(this)).reverse();\n\n    return returnFrozenWithMethods(tempArray, true);\n  },\n  shift: function shift() {\n    var tempArray = [].concat(_toConsumableArray(this.slice(1, this.length)));\n\n    return returnFrozenWithMethods(tempArray, true);\n  },\n  sort: function sort(sortFunction) {\n    var tempArray = (0, _utils.getMutableObject)(this);\n\n    tempArray.sort(sortFunction);\n\n    return crioArray(tempArray);\n  },\n  splice: function splice(startIndex) {\n    for (var _len5 = arguments.length, items = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n      items[_key5 - 2] = arguments[_key5];\n    }\n\n    var deleteCount = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];\n\n    startIndex = (0, _utils.coerceToInteger)(startIndex);\n    deleteCount = (0, _utils.coerceToInteger)(deleteCount);\n\n    items.forEach(function (item, itemIndex) {\n      items[itemIndex] = crio(item);\n    });\n\n    var tempArray = [].concat(_toConsumableArray(this.slice(0, startIndex)), items, _toConsumableArray(this.slice(startIndex + deleteCount, this.length)));\n\n    return returnFrozenWithMethods(tempArray, true);\n  },\n  unshift: function unshift() {\n    for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    args.forEach(function (arg, argIndex) {\n      args[argIndex] = crio(arg);\n    });\n\n    var tempArray = [].concat(args, _toConsumableArray(this));\n\n    return returnFrozenWithMethods(tempArray, true);\n  }\n};\nvar objectAdditionalMethods = {\n  filter: function filter(filterFunction) {\n    var thisProperties = GET_OWN_PROPERTY_NAMES(this);\n\n    var newObject = addObjectPrototypeMethods({});\n\n    for (var index = 0, length = thisProperties.length; index < length; index++) {\n      var property = thisProperties[index];\n      var descriptor = GET_OWN_PROPERTY_DESCRIPTOR(this, property);\n      var result = filterFunction.call(this, this[property], property, this);\n\n      if (result !== false && property !== _crioIdentifier2.default) {\n        (0, _utils.setImmutable)(newObject, property, this[property], descriptor);\n      }\n    }\n\n    return FREEZE(newObject);\n  },\n  forEach: function forEach(forEachFunction) {\n    var thisProperties = KEYS(this);\n\n    for (var index = 0, length = thisProperties.length; index < length; index++) {\n      var property = thisProperties[index];\n      var result = forEachFunction.call(this, this[property], property, this);\n\n      if (result === false) {\n        break;\n      }\n    }\n\n    return this;\n  },\n  map: function map(mapFunction) {\n    var thisProperties = GET_OWN_PROPERTY_NAMES(this);\n\n    var newObject = addObjectPrototypeMethods({});\n\n    for (var index = 0, length = thisProperties.length; index < length; index++) {\n      var property = thisProperties[index];\n      var descriptor = GET_OWN_PROPERTY_DESCRIPTOR(this, property);\n\n      if (property !== _crioIdentifier2.default) {\n        (0, _utils.setImmutable)(newObject, property, mapFunction.call(this, this[property], property, this), descriptor);\n      }\n    }\n\n    return FREEZE(newObject);\n  }\n};\n\nvar arrayMethods = _extends({}, allAdditionalMethods, arrayAdditionalMethods);\n\nimmutableArrayMethods.onlyApplyMethods.forEach(function (method) {\n  arrayMethods[method] = function () {\n    for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n\n    args.forEach(function (arg, argIndex) {\n      args[argIndex] = crio(arg);\n    });\n\n    return returnFrozenWithMethods(Array.prototype[method].apply(this, args), true);\n  };\n});\n\nimmutableArrayMethods.fullCrio.forEach(function (method) {\n  arrayMethods[method] = function () {\n    for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n\n    args.forEach(function (arg, argIndex) {\n      args[argIndex] = crio(arg);\n    });\n\n    return crio(Array.prototype[method].apply(this, args));\n  };\n});\n\nvar objectMethods = _extends({}, Object.prototype, allAdditionalMethods, objectAdditionalMethods);\n\nvar addArrayPrototypeMethods = function addArrayPrototypeMethods(array) {\n  if (isCrio(array)) {\n    return array;\n  }\n\n  var newArray = ASSIGN([], array, arrayMethods);\n\n  setCrioIdentifier(newArray);\n\n  return newArray;\n};\n\nvar addObjectPrototypeMethods = function addObjectPrototypeMethods(object) {\n  if (isCrio(object)) {\n    return object;\n  }\n\n  var newObject = CREATE(objectMethods);\n\n  setCrioIdentifier(newObject);\n\n  GET_OWN_PROPERTY_NAMES(object).forEach(function (property) {\n    var descriptor = GET_OWN_PROPERTY_DESCRIPTOR(object, property);\n\n    DEFINE_PROPERTY(newObject, property, descriptor);\n  });\n\n  return newObject;\n};\n\nvar returnFrozenWithMethods = function returnFrozenWithMethods(object, isObjectArray) {\n  var addMethods = isObjectArray ? addArrayPrototypeMethods : addObjectPrototypeMethods;\n\n  return FREEZE(addMethods(object));\n};\n\nvar setCrioIdentifier = function setCrioIdentifier(object) {\n  DEFINE_PROPERTY(object, _crioIdentifier2.default, {\n    configurable: false,\n    enumerable: false,\n    value: true,\n    writable: true\n  });\n};\n\nvar crioArray = function crioArray(array) {\n  var crioedArray = addArrayPrototypeMethods([]);\n\n  array.forEach(function (item, itemIndex) {\n    var itemValue = item;\n\n    if (!isCrio(item)) {\n      if ((0, _utils.isArray)(item)) {\n        itemValue = crioArray(item);\n      } else if ((0, _utils.isObject)(item)) {\n        itemValue = crioObject(item);\n      }\n    }\n\n    (0, _utils.setImmutable)(crioedArray, itemIndex, itemValue);\n  });\n\n  setCrioIdentifier(crioedArray);\n\n  return FREEZE(crioedArray);\n};\n\nvar crioObject = function crioObject(object) {\n  var crioedObject = CREATE(objectMethods);\n\n  GET_OWN_PROPERTY_NAMES(object).forEach(function (property) {\n    var itemValue = object[property];\n\n    if (!isCrio(itemValue)) {\n      if ((0, _utils.isArray)(itemValue)) {\n        itemValue = crioArray(itemValue);\n      } else if ((0, _utils.isObject)(itemValue)) {\n        itemValue = crioObject(itemValue);\n      }\n    }\n\n    setCrioIdentifier(crioedObject);\n    (0, _utils.setImmutable)(crioedObject, property, itemValue, GET_OWN_PROPERTY_DESCRIPTOR(object, property));\n  });\n\n  return FREEZE(crioedObject);\n};\n\nvar crio = function crio() {\n  var object = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n  if (isCrio(object)) {\n    return object;\n  }\n\n  if ((0, _utils.isArray)(object)) {\n    return crioArray(object);\n  }\n\n  if ((0, _utils.isObject)(object)) {\n    return crioObject(object);\n  }\n\n  return object;\n};\n\ncrio.array = function () {\n  var array = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n  return crioArray(array);\n};\n\ncrio.object = function () {\n  var object = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n  return crioObject(object);\n};\n\nexports.default = crio;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvaW5kZXguanM/MWZkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ1JJT19JREVOVElGSUVSIGZyb20gJy4vY3Jpb0lkZW50aWZpZXInO1xuaW1wb3J0IHtcbiAgY29lcmNlVG9JbnRlZ2VyLFxuICBnZXRNdXRhYmxlT2JqZWN0LFxuICBnZXRSZXN0T2ZPYmplY3QsXG4gIGlzQXJyYXksXG4gIGlzRXF1YWwsXG4gIGlzT2JqZWN0LFxuICBpc1VuZGVmaW5lZCxcbiAgc2V0SW1tdXRhYmxlXG59IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBpbW11dGFibGVBcnJheU1ldGhvZHMgPSB7XG4gIG9ubHlBcHBseU1ldGhvZHM6IFtcbiAgICAnZmlsdGVyJyxcbiAgICAnc2xpY2UnXG4gIF0sXG4gIGZ1bGxDcmlvOiBbXG4gICAgJ2pvaW4nLFxuICAgICdtYXAnLFxuICAgICdyZWR1Y2UnLFxuICAgICdyZWR1Y2VSaWdodCdcbiAgXVxufTtcblxuY29uc3QgQVNTSUdOID0gT2JqZWN0LmFzc2lnbjtcbmNvbnN0IENSRUFURSA9IE9iamVjdC5jcmVhdGU7XG5jb25zdCBERUZJTkVfUFJPUEVSVFkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5jb25zdCBGUkVFWkUgPSBPYmplY3QuZnJlZXplO1xuY29uc3QgR0VUX09XTl9QUk9QRVJUWV9ERVNDUklQVE9SID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmNvbnN0IEdFVF9PV05fUFJPUEVSVFlfTkFNRVMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbmNvbnN0IEtFWVMgPSBPYmplY3Qua2V5cztcblxuY29uc3QgaXNDcmlvID0gKG9iamVjdCkgPT4ge1xuICByZXR1cm4gISFvYmplY3RbQ1JJT19JREVOVElGSUVSXTtcbn07XG5cbmNvbnN0IGFsbEFkZGl0aW9uYWxNZXRob2RzID0ge1xuICBkZWxldGUoa2V5KSB7XG4gICAgaWYgKGlzQXJyYXkodGhpcykpIHtcbiAgICAgIHJldHVybiBnZXRSZXN0T2ZPYmplY3QodGhpcywga2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuRnJvemVuV2l0aE1ldGhvZHMoe1xuICAgICAgLi4uZ2V0UmVzdE9mT2JqZWN0KHRoaXMsIGtleSlcbiAgICB9LCBmYWxzZSk7XG4gIH0sXG5cbiAgZGVsZXRlSW4oa2V5cykge1xuICAgIGlmICghaXNBcnJheShrZXlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgbGFzdEtleUluZGV4ID0ga2V5cy5sZW5ndGggLSAxO1xuXG4gICAgbGV0IGN1cnJlbnRPYmplY3QgPSB0aGlzLnRoYXcoKSxcbiAgICAgICAgcmVmZXJlbmNlVG9DdXJyZW50T2JqZWN0ID0gY3VycmVudE9iamVjdDtcblxuICAgIGZvciAobGV0IGtleUluZGV4ID0gMCwgbGVuZ3RoID0gbGFzdEtleUluZGV4ICsgMTsga2V5SW5kZXggPCBsZW5ndGg7IGtleUluZGV4KyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNba2V5SW5kZXhdO1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gY3VycmVudE9iamVjdFtrZXldO1xuXG4gICAgICBpZiAoa2V5SW5kZXggPT09IGxhc3RLZXlJbmRleCkge1xuICAgICAgICBkZWxldGUgY3VycmVudE9iamVjdFtrZXldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0FycmF5KGN1cnJlbnRWYWx1ZSkgJiYgIWlzT2JqZWN0KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRPYmplY3QgPSBjdXJyZW50T2JqZWN0W2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyaW8ocmVmZXJlbmNlVG9DdXJyZW50T2JqZWN0KTtcbiAgfSxcblxuICBlcXVhbHMob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzRXF1YWwodGhpcywgb2JqZWN0KTtcbiAgfSxcblxuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXNba2V5XTtcbiAgfSxcblxuICBnZXRJbihrZXlzKSB7XG4gICAgaWYgKCFpc0FycmF5KGtleXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0S2V5SW5kZXggPSBrZXlzLmxlbmd0aCAtIDE7XG5cbiAgICBsZXQgY3VycmVudE9iamVjdCA9IHRoaXM7XG5cbiAgICBmb3IgKGxldCBrZXlJbmRleCA9IDAsIGxlbmd0aCA9IGxhc3RLZXlJbmRleCArIDE7IGtleUluZGV4IDwgbGVuZ3RoOyBrZXlJbmRleCsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2tleUluZGV4XTtcblxuICAgICAgaWYgKGlzVW5kZWZpbmVkKGN1cnJlbnRPYmplY3Rba2V5XSkgfHwga2V5SW5kZXggPT09IGxhc3RLZXlJbmRleCkge1xuICAgICAgICByZXR1cm4gY3VycmVudE9iamVjdFtrZXldO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50T2JqZWN0ID0gY3VycmVudE9iamVjdFtrZXldO1xuICAgIH1cbiAgfSxcblxuICBsb2codGl0bGUpIHtcbiAgICBjb25zdCB0aGF3ZWQgPSB0aGlzLnRoYXcoKTtcblxuICAgIGlmICh0aXRsZSkge1xuICAgICAgY29uc29sZS5sb2codGl0bGUsIHRoYXdlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKHRoYXdlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgbWVyZ2UoLi4ub2JqZWN0cykge1xuICAgIGNvbnN0IGlzVGhpc0FycmF5ID0gaXNBcnJheSh0aGlzKTtcblxuICAgIGxldCBzaGFsbG93Q2xvbmUgPSBpc1RoaXNBcnJheSA/IFsuLi50aGlzXSA6IHsuLi50aGlzfTtcblxuICAgIG9iamVjdHMuZm9yRWFjaCgob2JqZWN0KSA9PiB7XG4gICAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIHNoYWxsb3dDbG9uZVtrZXldID0gY3JpbyhvYmplY3Rba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV0dXJuRnJvemVuV2l0aE1ldGhvZHMoc2hhbGxvd0Nsb25lLCBpc1RoaXNBcnJheSk7XG4gIH0sXG5cbiAgbWVyZ2VJbihrZXlzLCAuLi5vYmplY3RzKSB7XG4gICAgaWYgKCFpc0FycmF5KGtleXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0S2V5SW5kZXggPSBrZXlzLmxlbmd0aCAtIDE7XG5cbiAgICBsZXQgY3VycmVudE9iamVjdCA9IHRoaXMudGhhdygpLFxuICAgICAgICByZWZlcmVuY2VUb0N1cnJlbnRPYmplY3QgPSBjdXJyZW50T2JqZWN0O1xuXG4gICAgZm9yIChsZXQga2V5SW5kZXggPSAwLCBsZW5ndGggPSBsYXN0S2V5SW5kZXggKyAxOyBrZXlJbmRleCA8IGxlbmd0aDsga2V5SW5kZXgrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1trZXlJbmRleF07XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBjdXJyZW50T2JqZWN0W2tleV07XG5cbiAgICAgIGlmICghaXNBcnJheShjdXJyZW50VmFsdWUpICYmICFpc09iamVjdChjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgIGN1cnJlbnRPYmplY3Rba2V5XSA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5SW5kZXggPT09IGxhc3RLZXlJbmRleCkge1xuICAgICAgICBjdXJyZW50T2JqZWN0W2tleV0gPSB0aGlzLm1lcmdlLmFwcGx5KGN1cnJlbnRPYmplY3Rba2V5XSwgb2JqZWN0cyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50T2JqZWN0ID0gY3VycmVudE9iamVjdFtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiBjcmlvKHJlZmVyZW5jZVRvQ3VycmVudE9iamVjdCwgaXNBcnJheSh0aGlzKSk7XG4gIH0sXG5cbiAgbXV0YXRlKG11dGF0ZU1hcEZ1bmN0aW9uKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbXV0YXRlTWFwRnVuY3Rpb24uY2FsbCh0aGlzLCB0aGlzLnRoYXcoKSk7XG5cbiAgICByZXR1cm4gY3JpbyhyZXN1bHQpO1xuICB9LFxuXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IGlzVGhpc0FycmF5ID0gaXNBcnJheSh0aGlzKTtcblxuICAgIGlmIChpc1RoaXNBcnJheSkge1xuICAgICAgcmV0dXJuIHRoaXMubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGl0ZW1JbmRleCA9PT0ga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGNyaW8odmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuRnJvemVuV2l0aE1ldGhvZHMoe1xuICAgICAgLi4uZ2V0UmVzdE9mT2JqZWN0KHRoaXMsIGtleSksXG4gICAgICBba2V5XTogY3Jpbyh2YWx1ZSlcbiAgICB9LCBpc1RoaXNBcnJheSk7XG4gIH0sXG5cbiAgc2V0SW4oa2V5cywgdmFsdWUpIHtcbiAgICBpZiAoIWlzQXJyYXkoa2V5cykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IGxhc3RLZXlJbmRleCA9IGtleXMubGVuZ3RoIC0gMTtcblxuICAgIGxldCBjdXJyZW50T2JqZWN0ID0gdGhpcy50aGF3KCksXG4gICAgICAgIHJlZmVyZW5jZVRvQ3VycmVudE9iamVjdCA9IGN1cnJlbnRPYmplY3Q7XG5cbiAgICBmb3IgKGxldCBrZXlJbmRleCA9IDAsIGxlbmd0aCA9IGxhc3RLZXlJbmRleCArIDE7IGtleUluZGV4IDwgbGVuZ3RoOyBrZXlJbmRleCsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2tleUluZGV4XTtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRPYmplY3Rba2V5XTtcblxuICAgICAgaWYgKCFpc0FycmF5KGN1cnJlbnRWYWx1ZSkgJiYgIWlzT2JqZWN0KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgY3VycmVudE9iamVjdFtrZXldID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXlJbmRleCA9PT0gbGFzdEtleUluZGV4KSB7XG4gICAgICAgIGN1cnJlbnRPYmplY3Rba2V5XSA9IGNyaW8odmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY3VycmVudE9iamVjdCA9IGN1cnJlbnRPYmplY3Rba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JpbyhyZWZlcmVuY2VUb0N1cnJlbnRPYmplY3QpO1xuICB9LFxuXG4gIHRoYXcoKSB7XG4gICAgcmV0dXJuIGdldE11dGFibGVPYmplY3QodGhpcyk7XG4gIH1cbn07XG5jb25zdCBhcnJheUFkZGl0aW9uYWxNZXRob2RzID0ge1xuICBjb25jYXQoLi4uYXJncykge1xuICAgIGFyZ3MuZm9yRWFjaCgoYXJnLCBhcmdJbmRleCkgPT4ge1xuICAgICAgYXJnc1thcmdJbmRleF0gPSBjcmlvKGFyZyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV0dXJuRnJvemVuV2l0aE1ldGhvZHMoQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLCBhcmdzKSwgdHJ1ZSk7XG4gIH0sXG5cbiAgY29weVdpdGhpbih0YXJnZXRJbmRleCwgc3RhcnRJbmRleCwgZW5kSW5kZXggPSB0aGlzLmxlbmd0aCkge1xuICAgIHRhcmdldEluZGV4ID0gY29lcmNlVG9JbnRlZ2VyKHRhcmdldEluZGV4KTtcbiAgICBzdGFydEluZGV4ID0gY29lcmNlVG9JbnRlZ2VyKHN0YXJ0SW5kZXgpO1xuICAgIGVuZEluZGV4ID0gY29lcmNlVG9JbnRlZ2VyKGVuZEluZGV4KTtcblxuICAgIGlmIChzdGFydEluZGV4IDwgMCkge1xuICAgICAgc3RhcnRJbmRleCA9IHRoaXMubGVuZ3RoICsgc3RhcnRJbmRleDtcbiAgICB9XG5cbiAgICBpZiAoZW5kSW5kZXggPCAwKSB7XG4gICAgICBlbmRJbmRleCA9IHRoaXMubGVuZ3RoICsgZW5kSW5kZXg7XG4gICAgfVxuXG4gICAgY29uc3QgY29weVZhbHVlcyA9IHRoaXMuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuXG4gICAgbGV0IGNvcHlJbmRleCA9IDA7XG5cbiAgICByZXR1cm4gdGhpcy5tYXAoKGl0ZW0sIGl0ZW1JbmRleCkgPT4ge1xuICAgICAgaWYgKGNvcHlJbmRleCA9PT0gY29weVZhbHVlcy5sZW5ndGggfHwgaXRlbUluZGV4ID49IHN0YXJ0SW5kZXggJiYgaXRlbUluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG5cbiAgICAgIGNvcHlJbmRleCsrO1xuXG4gICAgICByZXR1cm4gY29weVZhbHVlc1tjb3B5SW5kZXggLSAxXTtcbiAgICB9KTtcbiAgfSxcblxuICBmaWxsKHZhbHVlLCBzdGFydEluZGV4ID0gMCwgZW5kSW5kZXggPSB0aGlzLmxlbmd0aCkge1xuICAgIHN0YXJ0SW5kZXggPSBjb2VyY2VUb0ludGVnZXIoc3RhcnRJbmRleCk7XG4gICAgZW5kSW5kZXggPSBjb2VyY2VUb0ludGVnZXIoZW5kSW5kZXgpO1xuXG4gICAgdmFsdWUgPSBjcmlvKHZhbHVlKTtcblxuICAgIGlmIChzdGFydEluZGV4IDwgMCkge1xuICAgICAgc3RhcnRJbmRleCA9IHRoaXMubGVuZ3RoICsgc3RhcnRJbmRleDtcbiAgICB9XG5cbiAgICBpZiAoZW5kSW5kZXggPCAwKSB7XG4gICAgICBlbmRJbmRleCA9IHRoaXMubGVuZ3RoICsgZW5kSW5kZXg7XG4gICAgfVxuXG4gICAgbGV0IHRlbXBBcnJheSA9IFtdO1xuXG4gICAgdGhpcy5mb3JFYWNoKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcbiAgICAgIGlmIChpdGVtSW5kZXggPj0gc3RhcnRJbmRleCAmJiBpdGVtSW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICB0ZW1wQXJyYXlbaXRlbUluZGV4XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcEFycmF5W2l0ZW1JbmRleF0gPSBpdGVtO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldHVybkZyb3plbldpdGhNZXRob2RzKHRlbXBBcnJheSwgdHJ1ZSk7XG4gIH0sXG5cbiAgZm9yRWFjaChmb3JFYWNoRnVuY3Rpb24pIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IHRoaXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZm9yRWFjaEZ1bmN0aW9uLmNhbGwodGhpcywgdGhpc1tpbmRleF0sIGluZGV4LCB0aGlzKTtcblxuICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHBvcCgpIHtcbiAgICBjb25zdCB0ZW1wQXJyYXkgPSBbXG4gICAgICAuLi50aGlzLnNsaWNlKDAsIHRoaXMubGVuZ3RoIC0gMSlcbiAgICBdO1xuXG4gICAgcmV0dXJuIHJldHVybkZyb3plbldpdGhNZXRob2RzKHRlbXBBcnJheSwgdHJ1ZSk7XG4gIH0sXG5cbiAgcHVzaCguLi5hcmdzKSB7XG4gICAgbGV0IHRlbXBBcnJheSA9IFsuLi50aGlzXSxcbiAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG5cbiAgICBhcmdzLmZvckVhY2goKGFyZykgPT4ge1xuICAgICAgc2V0SW1tdXRhYmxlKHRlbXBBcnJheSwgbGVuZ3RoLCBjcmlvKGFyZykpO1xuICAgICAgbGVuZ3RoKys7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV0dXJuRnJvemVuV2l0aE1ldGhvZHModGVtcEFycmF5LCB0cnVlKTtcbiAgfSxcblxuICByZXZlcnNlKCkge1xuICAgIGNvbnN0IHRlbXBBcnJheSA9IFsuLi50aGlzXS5yZXZlcnNlKCk7XG5cbiAgICByZXR1cm4gcmV0dXJuRnJvemVuV2l0aE1ldGhvZHModGVtcEFycmF5LCB0cnVlKTtcbiAgfSxcblxuICBzaGlmdCgpIHtcbiAgICBjb25zdCB0ZW1wQXJyYXkgPSBbXG4gICAgICAuLi50aGlzLnNsaWNlKDEsIHRoaXMubGVuZ3RoKVxuICAgIF07XG5cbiAgICByZXR1cm4gcmV0dXJuRnJvemVuV2l0aE1ldGhvZHModGVtcEFycmF5LCB0cnVlKTtcbiAgfSxcblxuICBzb3J0KHNvcnRGdW5jdGlvbikge1xuICAgIGxldCB0ZW1wQXJyYXkgPSBnZXRNdXRhYmxlT2JqZWN0KHRoaXMpO1xuXG4gICAgdGVtcEFycmF5LnNvcnQoc29ydEZ1bmN0aW9uKTtcblxuICAgIHJldHVybiBjcmlvQXJyYXkodGVtcEFycmF5KTtcbiAgfSxcblxuICBzcGxpY2Uoc3RhcnRJbmRleCwgZGVsZXRlQ291bnQgPSAxLCAuLi5pdGVtcykge1xuICAgIHN0YXJ0SW5kZXggPSBjb2VyY2VUb0ludGVnZXIoc3RhcnRJbmRleCk7XG4gICAgZGVsZXRlQ291bnQgPSBjb2VyY2VUb0ludGVnZXIoZGVsZXRlQ291bnQpO1xuXG4gICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICBpdGVtc1tpdGVtSW5kZXhdID0gY3JpbyhpdGVtKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHRlbXBBcnJheSA9IFtcbiAgICAgIC4uLnRoaXMuc2xpY2UoMCwgc3RhcnRJbmRleCksXG4gICAgICAuLi5pdGVtcyxcbiAgICAgIC4uLnRoaXMuc2xpY2Uoc3RhcnRJbmRleCArIGRlbGV0ZUNvdW50LCB0aGlzLmxlbmd0aClcbiAgICBdO1xuXG4gICAgcmV0dXJuIHJldHVybkZyb3plbldpdGhNZXRob2RzKHRlbXBBcnJheSwgdHJ1ZSk7XG4gIH0sXG5cbiAgdW5zaGlmdCguLi5hcmdzKSB7XG4gICAgYXJncy5mb3JFYWNoKChhcmcsIGFyZ0luZGV4KSA9PiB7XG4gICAgICBhcmdzW2FyZ0luZGV4XSA9IGNyaW8oYXJnKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHRlbXBBcnJheSA9IFtcbiAgICAgIC4uLmFyZ3MsXG4gICAgICAuLi50aGlzXG4gICAgXTtcblxuICAgIHJldHVybiByZXR1cm5Gcm96ZW5XaXRoTWV0aG9kcyh0ZW1wQXJyYXksIHRydWUpO1xuICB9XG59O1xuY29uc3Qgb2JqZWN0QWRkaXRpb25hbE1ldGhvZHMgPSB7XG4gIGZpbHRlcihmaWx0ZXJGdW5jdGlvbikge1xuICAgIGNvbnN0IHRoaXNQcm9wZXJ0aWVzID0gR0VUX09XTl9QUk9QRVJUWV9OQU1FUyh0aGlzKTtcblxuICAgIGxldCBuZXdPYmplY3QgPSBhZGRPYmplY3RQcm90b3R5cGVNZXRob2RzKHt9KTtcblxuICAgIGZvciAobGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gdGhpc1Byb3BlcnRpZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSB0aGlzUHJvcGVydGllc1tpbmRleF07XG4gICAgICBjb25zdCBkZXNjcmlwdG9yID0gR0VUX09XTl9QUk9QRVJUWV9ERVNDUklQVE9SKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZpbHRlckZ1bmN0aW9uLmNhbGwodGhpcywgdGhpc1twcm9wZXJ0eV0sIHByb3BlcnR5LCB0aGlzKTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UgJiYgcHJvcGVydHkgIT09IENSSU9fSURFTlRJRklFUikge1xuICAgICAgICBzZXRJbW11dGFibGUobmV3T2JqZWN0LCBwcm9wZXJ0eSwgdGhpc1twcm9wZXJ0eV0sIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBGUkVFWkUobmV3T2JqZWN0KTtcbiAgfSxcblxuICBmb3JFYWNoKGZvckVhY2hGdW5jdGlvbikge1xuICAgIGNvbnN0IHRoaXNQcm9wZXJ0aWVzID0gS0VZUyh0aGlzKTtcblxuICAgIGZvciAobGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gdGhpc1Byb3BlcnRpZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSB0aGlzUHJvcGVydGllc1tpbmRleF07XG4gICAgICBjb25zdCByZXN1bHQgPSBmb3JFYWNoRnVuY3Rpb24uY2FsbCh0aGlzLCB0aGlzW3Byb3BlcnR5XSwgcHJvcGVydHksIHRoaXMpO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBtYXAobWFwRnVuY3Rpb24pIHtcbiAgICBjb25zdCB0aGlzUHJvcGVydGllcyA9IEdFVF9PV05fUFJPUEVSVFlfTkFNRVModGhpcyk7XG5cbiAgICBsZXQgbmV3T2JqZWN0ID0gYWRkT2JqZWN0UHJvdG90eXBlTWV0aG9kcyh7fSk7XG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IHRoaXNQcm9wZXJ0aWVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpc1Byb3BlcnRpZXNbaW5kZXhdO1xuICAgICAgY29uc3QgZGVzY3JpcHRvciA9IEdFVF9PV05fUFJPUEVSVFlfREVTQ1JJUFRPUih0aGlzLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChwcm9wZXJ0eSAhPT0gQ1JJT19JREVOVElGSUVSKSB7XG4gICAgICAgIHNldEltbXV0YWJsZShuZXdPYmplY3QsIHByb3BlcnR5LCBtYXBGdW5jdGlvbi5jYWxsKHRoaXMsIHRoaXNbcHJvcGVydHldLCBwcm9wZXJ0eSwgdGhpcyksIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBGUkVFWkUobmV3T2JqZWN0KTtcbiAgfVxufTtcblxubGV0IGFycmF5TWV0aG9kcyA9IHtcbiAgLi4uYWxsQWRkaXRpb25hbE1ldGhvZHMsXG4gIC4uLmFycmF5QWRkaXRpb25hbE1ldGhvZHNcbn07XG5cbmltbXV0YWJsZUFycmF5TWV0aG9kcy5vbmx5QXBwbHlNZXRob2RzLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICBhcnJheU1ldGhvZHNbbWV0aG9kXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgYXJncy5mb3JFYWNoKChhcmcsIGFyZ0luZGV4KSA9PiB7XG4gICAgICBhcmdzW2FyZ0luZGV4XSA9IGNyaW8oYXJnKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXR1cm5Gcm96ZW5XaXRoTWV0aG9kcyhBcnJheS5wcm90b3R5cGVbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKSwgdHJ1ZSk7XG4gIH07XG59KTtcblxuaW1tdXRhYmxlQXJyYXlNZXRob2RzLmZ1bGxDcmlvLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICBhcnJheU1ldGhvZHNbbWV0aG9kXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgYXJncy5mb3JFYWNoKChhcmcsIGFyZ0luZGV4KSA9PiB7XG4gICAgICBhcmdzW2FyZ0luZGV4XSA9IGNyaW8oYXJnKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjcmlvKEFycmF5LnByb3RvdHlwZVttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgfTtcbn0pO1xuXG5jb25zdCBvYmplY3RNZXRob2RzID0ge1xuICAuLi5PYmplY3QucHJvdG90eXBlLFxuICAuLi5hbGxBZGRpdGlvbmFsTWV0aG9kcyxcbiAgLi4ub2JqZWN0QWRkaXRpb25hbE1ldGhvZHNcbn07XG5cbmNvbnN0IGFkZEFycmF5UHJvdG90eXBlTWV0aG9kcyA9IChhcnJheSkgPT4ge1xuICBpZiAoaXNDcmlvKGFycmF5KSkge1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIGxldCBuZXdBcnJheSA9IEFTU0lHTihbXSwgYXJyYXksIGFycmF5TWV0aG9kcyk7XG5cbiAgc2V0Q3Jpb0lkZW50aWZpZXIobmV3QXJyYXkpO1xuXG4gIHJldHVybiBuZXdBcnJheTtcbn07XG5cbmNvbnN0IGFkZE9iamVjdFByb3RvdHlwZU1ldGhvZHMgPSAob2JqZWN0KSA9PiB7XG4gIGlmIChpc0NyaW8ob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICBsZXQgbmV3T2JqZWN0ID0gQ1JFQVRFKG9iamVjdE1ldGhvZHMpO1xuXG4gIHNldENyaW9JZGVudGlmaWVyKG5ld09iamVjdCk7XG5cbiAgR0VUX09XTl9QUk9QRVJUWV9OQU1FUyhvYmplY3QpLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IEdFVF9PV05fUFJPUEVSVFlfREVTQ1JJUFRPUihvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIERFRklORV9QUk9QRVJUWShuZXdPYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yKTtcbiAgfSk7XG5cbiAgcmV0dXJuIG5ld09iamVjdDtcbn07XG5cbmNvbnN0IHJldHVybkZyb3plbldpdGhNZXRob2RzID0gKG9iamVjdCwgaXNPYmplY3RBcnJheSkgPT4ge1xuICBjb25zdCBhZGRNZXRob2RzID0gaXNPYmplY3RBcnJheSA/IGFkZEFycmF5UHJvdG90eXBlTWV0aG9kcyA6IGFkZE9iamVjdFByb3RvdHlwZU1ldGhvZHM7XG5cbiAgcmV0dXJuIEZSRUVaRShhZGRNZXRob2RzKG9iamVjdCkpO1xufTtcblxuY29uc3Qgc2V0Q3Jpb0lkZW50aWZpZXIgPSAob2JqZWN0KSA9PiB7XG4gIERFRklORV9QUk9QRVJUWShvYmplY3QsIENSSU9fSURFTlRJRklFUiwge1xuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSk7XG59O1xuXG5jb25zdCBjcmlvQXJyYXkgPSAoYXJyYXkpID0+IHtcbiAgbGV0IGNyaW9lZEFycmF5ID0gYWRkQXJyYXlQcm90b3R5cGVNZXRob2RzKFtdKTtcblxuICBhcnJheS5mb3JFYWNoKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcbiAgICBsZXQgaXRlbVZhbHVlID0gaXRlbTtcblxuICAgIGlmICghaXNDcmlvKGl0ZW0pKSB7XG4gICAgICBpZiAoaXNBcnJheShpdGVtKSkge1xuICAgICAgICBpdGVtVmFsdWUgPSBjcmlvQXJyYXkoaXRlbSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIGl0ZW1WYWx1ZSA9IGNyaW9PYmplY3QoaXRlbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0SW1tdXRhYmxlKGNyaW9lZEFycmF5LCBpdGVtSW5kZXgsIGl0ZW1WYWx1ZSk7XG4gIH0pO1xuXG4gIHNldENyaW9JZGVudGlmaWVyKGNyaW9lZEFycmF5KTtcblxuICByZXR1cm4gRlJFRVpFKGNyaW9lZEFycmF5KTtcbn07XG5cbmNvbnN0IGNyaW9PYmplY3QgPSAob2JqZWN0KSA9PiB7XG4gIGxldCBjcmlvZWRPYmplY3QgPSBDUkVBVEUob2JqZWN0TWV0aG9kcyk7XG5cbiAgR0VUX09XTl9QUk9QRVJUWV9OQU1FUyhvYmplY3QpLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gICAgbGV0IGl0ZW1WYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG5cbiAgICBpZiAoIWlzQ3JpbyhpdGVtVmFsdWUpKSB7XG4gICAgICBpZiAoaXNBcnJheShpdGVtVmFsdWUpKSB7XG4gICAgICAgIGl0ZW1WYWx1ZSA9IGNyaW9BcnJheShpdGVtVmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChpdGVtVmFsdWUpKSB7XG4gICAgICAgIGl0ZW1WYWx1ZSA9IGNyaW9PYmplY3QoaXRlbVZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRDcmlvSWRlbnRpZmllcihjcmlvZWRPYmplY3QpO1xuICAgIHNldEltbXV0YWJsZShjcmlvZWRPYmplY3QsIHByb3BlcnR5LCBpdGVtVmFsdWUsIEdFVF9PV05fUFJPUEVSVFlfREVTQ1JJUFRPUihvYmplY3QsIHByb3BlcnR5KSk7XG4gIH0pO1xuXG4gIHJldHVybiBGUkVFWkUoY3Jpb2VkT2JqZWN0KTtcbn07XG5cbmNvbnN0IGNyaW8gPSAob2JqZWN0ID0ge30pID0+IHtcbiAgaWYgKGlzQ3JpbyhvYmplY3QpKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iamVjdCkpIHtcbiAgICByZXR1cm4gY3Jpb0FycmF5KG9iamVjdCk7XG4gIH1cblxuICBpZiAoaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBjcmlvT2JqZWN0KG9iamVjdCk7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufTtcblxuY3Jpby5hcnJheSA9IChhcnJheSA9IFtdKSA9PiB7XG4gIHJldHVybiBjcmlvQXJyYXkoYXJyYXkpO1xufTtcblxuY3Jpby5vYmplY3QgPSAob2JqZWN0ID0ge30pID0+IHtcbiAgcmV0dXJuIGNyaW9PYmplY3Qob2JqZWN0KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyaW87XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBzcmMvaW5kZXguanNcbiAqKi8iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUlBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUFBOzs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUFBOzs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBOzs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = '$$crio';\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvY3Jpb0lkZW50aWZpZXIuanM/YjQxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAnJCRjcmlvJztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBzcmMvY3Jpb0lkZW50aWZpZXIuanNcbiAqKi8iXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setImmutable = exports.getRestOfObject = exports.getMutableObject = exports.isUndefined = exports.isObject = exports.isEqual = exports.isArray = exports.coerceToInteger = undefined;\n\nvar _crioIdentifier = __webpack_require__(2);\n\nvar _crioIdentifier2 = _interopRequireDefault(_crioIdentifier);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar DEFINE_PROPERTY = Object.defineProperty;\nvar GET_OWN_PROPERTY_NAMES = Object.getOwnPropertyNames;\nvar TO_STRING = Object.prototype.toString;\n\nvar coerceToInteger = exports.coerceToInteger = function coerceToInteger(value) {\n  return +value | 0;\n};\n\nvar isArray = exports.isArray = function isArray(object) {\n  return TO_STRING.call(object) === '[object Array]';\n};\n\nvar isEqual = exports.isEqual = function isEqual(object1, object2) {\n  if (object1 === object2) {\n    return true;\n  }\n\n  if (!(isArray(object1) || isArray(object2)) && !(isObject(object1) || isObject(object2))) {\n    return false;\n  }\n\n  if (object1.prototype !== object2.prototype) {\n    return false;\n  }\n\n  var object1Properties = GET_OWN_PROPERTY_NAMES(object1);\n  var object2Properties = GET_OWN_PROPERTY_NAMES(object2);\n  var object1PropertiesLength = object1Properties.length;\n\n  if (object1PropertiesLength !== object2Properties.length) {\n    return false;\n  }\n\n  for (var index = 0; index < object1PropertiesLength; index++) {\n    if (object1Properties[index] !== object2Properties[index]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar isObject = exports.isObject = function isObject(object) {\n  return TO_STRING.call(object) === '[object Object]' && !!object;\n};\n\nvar isUndefined = exports.isUndefined = function isUndefined(object) {\n  return object === void 0;\n};\n\nvar setMutableProperty = function setMutableProperty(object, property, targetObject) {\n  var descriptor = Object.getOwnPropertyDescriptor(object, property) || {};\n\n  var value = object[property];\n\n  if (isArray(value) || isObject(value)) {\n    value = getMutableObject(value);\n  }\n\n  DEFINE_PROPERTY(targetObject, property, {\n    configurable: true,\n    enumerable: descriptor.enumerable || true,\n    value: value,\n    writable: true\n  });\n};\n\nvar getMutableObject = exports.getMutableObject = function getMutableObject(object) {\n  var isObjectArray = isArray(object);\n\n  var mutableObject = isObjectArray ? [] : {};\n\n  if (isObjectArray) {\n    object.forEach(function (item, itemIndex) {\n      setMutableProperty(object, itemIndex, mutableObject);\n    });\n  } else {\n    GET_OWN_PROPERTY_NAMES(object).forEach(function (property) {\n      if (property !== _crioIdentifier2.default) {\n        setMutableProperty(object, property, mutableObject);\n      }\n    });\n  }\n\n  return mutableObject;\n};\n\nvar getRestOfObject = exports.getRestOfObject = function getRestOfObject(object, key) {\n  if (isArray(object)) {\n    return object.filter(function (item, itemIndex) {\n      return itemIndex !== key;\n    });\n  }\n\n  var tempObject = _extends({}, object);\n\n  delete tempObject[key];\n\n  return tempObject;\n};\n\nvar setImmutable = exports.setImmutable = function setImmutable(object, property, value) {\n  var descriptor = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n  DEFINE_PROPERTY(object, property, {\n    get: function get() {\n      return value;\n    },\n    set: function set() {\n      throw new SyntaxError('Cannot set the value for this object property directly, please use either the .set() or .setIn() method.');\n    },\n\n    configurable: false,\n    enumerable: descriptor.enumerable || true\n  });\n\n  return object[property];\n};\n\nexports.default = {\n  coerceToInteger: coerceToInteger,\n  getMutableObject: getMutableObject,\n  getRestOfObject: getRestOfObject,\n  isArray: isArray,\n  isEqual: isEqual,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  setImmutable: setImmutable\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdXRpbHMuanM/MmI0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ1JJT19JREVOVElGSUVSIGZyb20gJy4vY3Jpb0lkZW50aWZpZXInO1xuXG5jb25zdCBERUZJTkVfUFJPUEVSVFkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5jb25zdCBHRVRfT1dOX1BST1BFUlRZX05BTUVTID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG5jb25zdCBUT19TVFJJTkcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5leHBvcnQgY29uc3QgY29lcmNlVG9JbnRlZ2VyID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiArdmFsdWUgfCAwO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzQXJyYXkgPSAob2JqZWN0KSA9PiB7XG4gIHJldHVybiBUT19TVFJJTkcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzRXF1YWwgPSAob2JqZWN0MSwgb2JqZWN0MikgPT4ge1xuICBpZiAob2JqZWN0MSA9PT0gb2JqZWN0Mikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKCEoaXNBcnJheShvYmplY3QxKSB8fCBpc0FycmF5KG9iamVjdDIpKSAmJiAhKGlzT2JqZWN0KG9iamVjdDEpIHx8IGlzT2JqZWN0KG9iamVjdDIpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChvYmplY3QxLnByb3RvdHlwZSAhPT0gb2JqZWN0Mi5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBvYmplY3QxUHJvcGVydGllcyA9IEdFVF9PV05fUFJPUEVSVFlfTkFNRVMob2JqZWN0MSk7XG4gIGNvbnN0IG9iamVjdDJQcm9wZXJ0aWVzID0gR0VUX09XTl9QUk9QRVJUWV9OQU1FUyhvYmplY3QyKTtcbiAgY29uc3Qgb2JqZWN0MVByb3BlcnRpZXNMZW5ndGggPSBvYmplY3QxUHJvcGVydGllcy5sZW5ndGg7XG5cbiAgaWYgKG9iamVjdDFQcm9wZXJ0aWVzTGVuZ3RoICE9PSBvYmplY3QyUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgb2JqZWN0MVByb3BlcnRpZXNMZW5ndGg7IGluZGV4KyspIHtcbiAgICBpZiAob2JqZWN0MVByb3BlcnRpZXNbaW5kZXhdICE9PSBvYmplY3QyUHJvcGVydGllc1tpbmRleF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmV4cG9ydCBjb25zdCBpc09iamVjdCA9IChvYmplY3QpID0+IHtcbiAgcmV0dXJuIFRPX1NUUklORy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmICEhb2JqZWN0O1xufTtcblxuZXhwb3J0IGNvbnN0IGlzVW5kZWZpbmVkID0gKG9iamVjdCkgPT4ge1xuICByZXR1cm4gb2JqZWN0ID09PSB2b2lkIDA7XG59O1xuXG5jb25zdCBzZXRNdXRhYmxlUHJvcGVydHkgPSAob2JqZWN0LCBwcm9wZXJ0eSwgdGFyZ2V0T2JqZWN0KSA9PiB7XG4gIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpIHx8IHt9O1xuXG4gIGxldCB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG5cbiAgaWYgKGlzQXJyYXkodmFsdWUpIHx8IGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhbHVlID0gZ2V0TXV0YWJsZU9iamVjdCh2YWx1ZSk7XG4gIH1cblxuICBERUZJTkVfUFJPUEVSVFkodGFyZ2V0T2JqZWN0LCBwcm9wZXJ0eSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgdHJ1ZSxcbiAgICB2YWx1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRNdXRhYmxlT2JqZWN0ID0gKG9iamVjdCkgPT4ge1xuICBjb25zdCBpc09iamVjdEFycmF5ID0gaXNBcnJheShvYmplY3QpO1xuXG4gIGxldCBtdXRhYmxlT2JqZWN0ID0gaXNPYmplY3RBcnJheSA/IFtdIDoge307XG5cbiAgaWYgKGlzT2JqZWN0QXJyYXkpIHtcbiAgICBvYmplY3QuZm9yRWFjaCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICBzZXRNdXRhYmxlUHJvcGVydHkob2JqZWN0LCBpdGVtSW5kZXgsIG11dGFibGVPYmplY3QpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIEdFVF9PV05fUFJPUEVSVFlfTkFNRVMob2JqZWN0KS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICAgICAgaWYgKHByb3BlcnR5ICE9PSBDUklPX0lERU5USUZJRVIpIHtcbiAgICAgICAgc2V0TXV0YWJsZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIG11dGFibGVPYmplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG11dGFibGVPYmplY3Q7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0UmVzdE9mT2JqZWN0ID0gKG9iamVjdCwga2V5KSA9PiB7XG4gIGlmIChpc0FycmF5KG9iamVjdCkpIHtcbiAgICByZXR1cm4gb2JqZWN0LmZpbHRlcigoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gaXRlbUluZGV4ICE9PSBrZXk7XG4gICAgfSk7XG4gIH1cblxuICBsZXQgdGVtcE9iamVjdCA9IHsuLi5vYmplY3R9O1xuXG4gIGRlbGV0ZSB0ZW1wT2JqZWN0W2tleV07XG5cbiAgcmV0dXJuIHRlbXBPYmplY3Q7XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0SW1tdXRhYmxlID0gKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBkZXNjcmlwdG9yID0ge30pID0+IHtcbiAgREVGSU5FX1BST1BFUlRZKG9iamVjdCwgcHJvcGVydHksIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBzZXQoKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Nhbm5vdCBzZXQgdGhlIHZhbHVlIGZvciB0aGlzIG9iamVjdCBwcm9wZXJ0eSBkaXJlY3RseSwgcGxlYXNlIHVzZSBlaXRoZXIgdGhlIC5zZXQoKSBvciAuc2V0SW4oKSBtZXRob2QuJyk7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCB0cnVlXG4gIH0pO1xuXG4gIHJldHVybiBvYmplY3RbcHJvcGVydHldO1xufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb2VyY2VUb0ludGVnZXIsXG4gIGdldE11dGFibGVPYmplY3QsXG4gIGdldFJlc3RPZk9iamVjdCxcbiAgaXNBcnJheSxcbiAgaXNFcXVhbCxcbiAgaXNPYmplY3QsXG4gIGlzVW5kZWZpbmVkLFxuICBzZXRJbW11dGFibGVcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogc3JjL3V0aWxzLmpzXG4gKiovIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }
/******/ ])
});
;